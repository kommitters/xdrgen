defmodule MyXDR do
  @moduledoc """
  Automatically generated by xdrgen
  DO NOT EDIT or your changes may be overwritten

  Target implementation: elixir_xdr at https://hex.pm/packages/elixir_xdr
  """

  comment ~S"""
  XDR Source Code::

      enum MessageType
      {
          ERROR_MSG,    
          HELLO,
          DONT_HAVE,
      
          GET_PEERS,   // gets a list of peers this guy knows about        
          PEERS,
      
          GET_TX_SET,  // gets a particular txset by hash        
          TX_SET,    
      
          GET_VALIDATIONS, // gets validations for a given ledger hash        
          VALIDATIONS,    
      
          TRANSACTION, //pass on a tx you have heard about        
          JSON_TRANSACTION,
      
          // FBA        
          GET_FBA_QUORUMSET,        
          FBA_QUORUMSET,    
          FBA_MESSAGE
      };
  """

  defmodule MessageType do
    @moduledoc """
    Representation of Stellar `MessageType` type.
    """

    @behaviour XDR.Declaration

    @declarations [
      ERROR_MSG: 0,
      HELLO: 1,
      DONT_HAVE: 2,
      GET_PEERS: 3,
      PEERS: 4,
      GET_TX_SET: 5,
      TX_SET: 6,
      GET_VALIDATIONS: 7,
      VALIDATIONS: 8,
      TRANSACTION: 9,
      JSON_TRANSACTION: 10,
      GET_FBA_QUORUMSET: 11,
      FBA_QUORUMSET: 12,
      FBA_MESSAGE: 13
    ]

    @enum_spec %XDR.Enum{declarations: @declarations, indentifier: nil}

    @type t :: %__MODULE__{identifier: atom()}

    defstruct [:identifier]

    @spec new(type :: atom()) :: t()
    def new(type \\ :ERROR_MSG), do: %__MODULE__{identifier: type}

    @impl true
    def encode_xdr(%__MODULE__{identifier: type}), do:
      @declarations
      |> XDR.Enum.new(type)
      |> XDR.Enum.encode_xdr()

    @impl true
    def encode_xdr!(%__MODULE__{identifier: type}), do:
      @declarations
      |> XDR.Enum.new(type)
      |> XDR.Enum.encode_xdr!()

    @impl true
    def decode_xdr(bytes, spec \\ @enum_spec)

    def decode_xdr(bytes, spec) do:
      case XDR.Enum.decode_xdr(bytes, spec) do
        {:ok, {%XDR.Enum{identifier: type}, rest}} -> {:ok, {new(type), rest}}
        error -> error
      end

    @impl true
    def decode_xdr!(bytes, spec \\ @enum_spec)

    def decode_xdr!(bytes, spec) do
      {%XDR.Enum{identifier: type}, rest} = XDR.Enum.decode_xdr!(bytes, spec)
      {new(type), rest}
    end
  end

  comment ~S"""
  XDR Source Code::

      enum Color {
          RED=0,  
          GREEN=1,  
          BLUE=2  
      };
  """

  defmodule Color do
    @moduledoc """
    Representation of Stellar `Color` type.
    """

    @behaviour XDR.Declaration

    @declarations [
      RED: 0,
      GREEN: 1,
      BLUE: 2
    ]

    @enum_spec %XDR.Enum{declarations: @declarations, indentifier: nil}

    @type t :: %__MODULE__{identifier: atom()}

    defstruct [:identifier]

    @spec new(type :: atom()) :: t()
    def new(type \\ :RED), do: %__MODULE__{identifier: type}

    @impl true
    def encode_xdr(%__MODULE__{identifier: type}), do:
      @declarations
      |> XDR.Enum.new(type)
      |> XDR.Enum.encode_xdr()

    @impl true
    def encode_xdr!(%__MODULE__{identifier: type}), do:
      @declarations
      |> XDR.Enum.new(type)
      |> XDR.Enum.encode_xdr!()

    @impl true
    def decode_xdr(bytes, spec \\ @enum_spec)

    def decode_xdr(bytes, spec) do:
      case XDR.Enum.decode_xdr(bytes, spec) do
        {:ok, {%XDR.Enum{identifier: type}, rest}} -> {:ok, {new(type), rest}}
        error -> error
      end

    @impl true
    def decode_xdr!(bytes, spec \\ @enum_spec)

    def decode_xdr!(bytes, spec) do
      {%XDR.Enum{identifier: type}, rest} = XDR.Enum.decode_xdr!(bytes, spec)
      {new(type), rest}
    end
  end

  comment ~S"""
  XDR Source Code::

      enum Color2 {
          RED2=RED,  
          GREEN2=1,  
          BLUE2=2  
      };
  """

  defmodule Color2 do
    @moduledoc """
    Representation of Stellar `Color2` type.
    """

    @behaviour XDR.Declaration

    @declarations [
      RED2: 0,
      GREEN2: 1,
      BLUE2: 2
    ]

    @enum_spec %XDR.Enum{declarations: @declarations, indentifier: nil}

    @type t :: %__MODULE__{identifier: atom()}

    defstruct [:identifier]

    @spec new(type :: atom()) :: t()
    def new(type \\ :RED2), do: %__MODULE__{identifier: type}

    @impl true
    def encode_xdr(%__MODULE__{identifier: type}), do:
      @declarations
      |> XDR.Enum.new(type)
      |> XDR.Enum.encode_xdr()

    @impl true
    def encode_xdr!(%__MODULE__{identifier: type}), do:
      @declarations
      |> XDR.Enum.new(type)
      |> XDR.Enum.encode_xdr!()

    @impl true
    def decode_xdr(bytes, spec \\ @enum_spec)

    def decode_xdr(bytes, spec) do:
      case XDR.Enum.decode_xdr(bytes, spec) do
        {:ok, {%XDR.Enum{identifier: type}, rest}} -> {:ok, {new(type), rest}}
        error -> error
      end

    @impl true
    def decode_xdr!(bytes, spec \\ @enum_spec)

    def decode_xdr!(bytes, spec) do
      {%XDR.Enum{identifier: type}, rest} = XDR.Enum.decode_xdr!(bytes, spec)
      {new(type), rest}
    end
  end

end
