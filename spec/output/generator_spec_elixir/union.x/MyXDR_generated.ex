defmodule MyXDR do
  @moduledoc """
  Automatically generated by xdrgen
  DO NOT EDIT or your changes may be overwritten

  Target implementation: elixir_xdr at https://hex.pm/packages/elixir_xdr
  """

  comment ~S"""
  XDR Source Code::

      typedef int Error;
  """

  define_type("Error", Int)

  comment ~S"""
  XDR Source Code::

      typedef int Multi;
  """

  define_type("Multi", Int)

  comment ~S"""
  XDR Source Code::

      enum UnionKey {
        ERROR,
        MULTI
      };
  """

  defmodule UnionKey do
    @moduledoc """
    Representation of Stellar `UnionKey` type.
    """

    @behaviour XDR.Declaration

    @declarations [
      ERROR: 0,
      MULTI: 1
    ]

    @enum_spec %XDR.Enum{declarations: @declarations, indentifier: nil}

    @type t :: %__MODULE__{identifier: atom()}

    defstruct [:identifier]

    @spec new(type :: atom()) :: t()
    def new(type \\ :ERROR), do: %__MODULE__{identifier: type}

    @impl true
    def encode_xdr(%__MODULE__{identifier: type}), do:
      @declarations
      |> XDR.Enum.new(type)
      |> XDR.Enum.encode_xdr()

    @impl true
    def encode_xdr!(%__MODULE__{identifier: type}), do:
      @declarations
      |> XDR.Enum.new(type)
      |> XDR.Enum.encode_xdr!()

    @impl true
    def decode_xdr(bytes, spec \\ @enum_spec)

    def decode_xdr(bytes, spec) do:
      case XDR.Enum.decode_xdr(bytes, spec) do
        {:ok, {%XDR.Enum{identifier: type}, rest}} -> {:ok, {new(type), rest}}
        error -> error
      end

    @impl true
    def decode_xdr!(bytes, spec \\ @enum_spec)

    def decode_xdr!(bytes, spec) do
      {%XDR.Enum{identifier: type}, rest} = XDR.Enum.decode_xdr!(bytes, spec)
      {new(type), rest}
    end
  end

  comment ~S"""
  XDR Source Code::

      union MyUnion switch (UnionKey type)
      {
          case ERROR:
              Error error;
          case MULTI:
              Multi things<>;
      
      
      };
  """

  define_type("MyUnion", Union,
    switch_type: "UnionKey",
    switch_name: :TYPE,
    switches: [
      {:ERROR, :ERROR},
      {:MULTI, :THINGS},
    ],
    arms: [
      ERROR: "Error",
      THINGS: build_type(VariableArray, max_length: 2147483647, type: "Multi"),
    ]
  )

  comment ~S"""
  XDR Source Code::

      union IntUnion switch (int type)
      {
          case 0:
              Error error;
          case 1:
              Multi things<>;
      
      };
  """

  define_type("IntUnion", Union,
    switch_type: build_type(Int),
    switch_name: :TYPE,
    switches: [
      {0, :ERROR},
      {1, :THINGS},
    ],
    arms: [
      ERROR: "Error",
      THINGS: build_type(VariableArray, max_length: 2147483647, type: "Multi"),
    ]
  )

  comment ~S"""
  XDR Source Code::

      typedef IntUnion IntUnion2;
  """

  define_type("IntUnion2", "IntUnion")

end
